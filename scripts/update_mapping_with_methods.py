#!/usr/bin/python3
"""
Update system_test_mapping.json with HTTP methods and test implementation files.
This script scans test files, extracts API calls, and updates the mapping.

Usage:
    python3 scripts/update_mapping_with_methods.py
    
Note: Uses system Python (/usr/bin/python3) to avoid output suppression issues with pyenv.
"""

import json
import re
import ast
import os
from pathlib import Path
from collections import defaultdict
from typing import Dict, Optional, Tuple

# Get the repository root (parent of scripts/)
REPO_ROOT = Path(__file__).parent.parent.resolve()

def load_json_file(path):
    """Load JSON file."""
    with open(path, 'r') as f:
        return json.load(f)

def save_json_file(path, data):
    """Save JSON file."""
    with open(path, 'w') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
        f.write('\n')

def extract_backend_api_calls(file_path):
    """Extract backend API method calls from a test file."""
    if not file_path.exists():
        return set()
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find all self.backend.method_name() or backend.method_name() calls
        # Pattern 1: Direct calls like self.backend.method_name(
        pattern1 = r'(?:self\.backend|backend|test_obj\.backend)\.(\w+)\('
        matches1 = re.findall(pattern1, content)
        
        # Pattern 2: Method references (passed as args) like self.backend.method_name
        # Look for backend.method_name NOT followed by ( to catch function references
        pattern2 = r'(?:self\.backend|backend|test_obj\.backend)\.(\w+)(?!\s*\()'
        matches2 = re.findall(pattern2, content)
        
        return set(matches1 + matches2)
    except Exception as e:
        print(f"Warning: Could not read {file_path}: {e}")
        return set()

def analyze_test_configuration_files():
    """
    Analyze test configuration files to extract test name to implementation file mappings.
    Returns: {test_name: [implementation_file_paths]}
    """
    config_dir = REPO_ROOT / 'configurations' / 'system' / 'tests_cases'
    test_to_files = {}
    
    for config_file in config_dir.glob('*.py'):
        if config_file.name.startswith('__'):
            continue
        
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parse the Python file
            try:
                tree = ast.parse(content)
            except:
                continue
            
            # Find all static method definitions (these are test configurations)
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    for item in node.body:
                        if isinstance(item, ast.FunctionDef):
                            test_name = item.name
                            
                            # Extract imports in the function
                            imported_files = []
                            for stmt in item.body:
                                if isinstance(stmt, ast.ImportFrom):
                                    if stmt.module and stmt.module.startswith('tests_scripts'):
                                        # Convert module path to file path
                                        module_parts = stmt.module.replace('tests_scripts.', '').split('.')
                                        file_path = 'tests_scripts/' + '/'.join(module_parts) + '.py'
                                        imported_files.append(file_path)
                            
                            if imported_files:
                                test_to_files[test_name] = imported_files
        
        except Exception as e:
            print(f"Warning processing {config_file}: {e}")
    
    return test_to_files

def get_api_method_mapping():
    """
    Create mapping of backend method names to their HTTP methods and paths.
    
    This mapping was generated by analyzing backend_api.py.
    Path parameters are represented with {param_name} placeholders (e.g., {incident_id}).
    These placeholders will match actual values when the test runs, but are used here
    to identify the API pattern for code mapping purposes.
    """
    return {
        'get_tenant_details': {'method': 'GET', 'path': '/api/v1/tenants/tenantDetails'},
        'create_tenant': {'method': 'POST', 'path': '/api/v1/tenants/createTenant'},
        'delete_tenant': {'method': 'DELETE', 'path': '/api/v1/admin/tenants'},
        'get_access_keys': {'method': 'GET', 'path': '/api/v1/authentication/accessKeys'},
        'stripe_billing_portal': {'method': 'GET', 'path': '/api/v1/tenants/stripe/portal'},
        'stripe_checkout': {'method': 'POST', 'path': '/api/v1/tenants/stripe/checkout'},
        'get_stripe_plans': {'method': 'GET', 'path': '/api/v1/tenants/stripe/plans'},
        'create_subscription': {'method': 'POST', 'path': '/api/v1/admin/createSubscription'},
        'cancel_subscription': {'method': 'POST', 'path': '/api/v1/admin/cancelSubscription'},
        'renew_subscription': {'method': 'POST', 'path': '/api/v1/admin/renewSubscription'},
        'get_posture_clusters_overtime': {'method': 'POST', 'path': '/api/v1/posture/clustersOvertime'},
        'get_posture_frameworks': {'method': 'POST', 'path': '/api/v1/posture/frameworks'},
        'get_posture_controls': {'method': 'POST', 'path': '/api/v1/posture/controls'},
        'get_top_controls_results': {'method': 'POST', 'path': '/api/v1/posture/topFailedControls'},
        'get_posture_resources': {'method': 'POST', 'path': '/api/v1/posture/resources'},
        'get_posture_clusters': {'method': 'POST', 'path': '/api/v1/posture/clusters'},
        'trigger_posture_scan': {'method': 'POST', 'path': '/api/v1/posture/scan'},
        'get_framework': {'method': 'GET', 'path': '/api/v1/framework'},
        'post_custom_framework': {'method': 'POST', 'path': '/api/v1/framework'},
        'put_custom_framework': {'method': 'PUT', 'path': '/api/v1/framework'},
        'delete_custom_framework': {'method': 'DELETE', 'path': '/api/v1/framework'},
        'get_scan_results_sum_summary': {'method': 'POST', 'path': '/api/v1/vulnerability/scanResultsSumSummary'},
        'get_scan_results_details': {'method': 'POST', 'path': '/api/v1/vulnerability/scanResultsDetails'},
        'get_unique_values_for_field_scan_summary': {'method': 'POST', 'path': '/api/v1/uniqueValues/vulnerability/scanResultsSumSummary'},
        'set_cves_exceptions': {'method': 'POST', 'path': '/api/v1/vulnerabilityExceptionPolicy'},
        'get_vuln_v2_workloads': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/workload'},
        'get_vuln_v2_workload_details': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/workload'},
        'get_vulns_v2': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/vulnerability'},
        'get_vuln_v2_vulnerabilities_uniquevalues': {'method': 'POST', 'path': '/api/v1/uniqueValues/vulnerability_v2/vulnerability'},
        'get_vuln_v2_details': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/vulnerability'},
        'get_vuln_v2_images': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/image'},
        'get_vuln_v2_components': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/component'},
        'get_vuln_v2_component_uniquevalues': {'method': 'POST', 'path': '/api/v1/uniqueValues/vulnerability_v2/component'},
        'get_vuln_v2_hosts': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/host'},
        'get_vuln_v2_host_uniquevalues': {'method': 'POST', 'path': '/api/v1/uniqueValues/vulnerability_v2/host'},
        'get_vuln_v2_host_details': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/host'},
        'get_vuln_v2_host_scan': {'method': 'POST', 'path': '/api/v1/vulnerability_v2/host/scan'},
        'get_repository_posture_repositories': {'method': 'POST', 'path': '/api/v1/repositoryPosture/repositories'},
        'get_repository_posture_repositories_by_name': {'method': 'POST', 'path': '/api/v1/repositoryPosture/repositories'},
        'get_repository_posture_repositories_by_report_guid': {'method': 'POST', 'path': '/api/v1/repositoryPosture/repositories'},
        'get_repository_posture_files': {'method': 'POST', 'path': '/api/v1/repositoryPosture/files'},
        'get_repository_posture_resources': {'method': 'POST', 'path': '/api/v1/repositoryPosture/resources'},
        'delete_repository': {'method': 'DELETE', 'path': '/api/v1/repositoryPosture'},
        'post_posture_exception': {'method': 'POST', 'path': '/api/v1/postureExceptionPolicy'},
        'get_all_posture_exception_by_cluster': {'method': 'GET', 'path': '/api/v1/postureExceptionPolicy'},
        'delete_posture_exception': {'method': 'DELETE', 'path': '/api/v1/postureExceptionPolicy'},
        'delete_all_posture_exceptions': {'method': 'DELETE', 'path': '/api/v1/postureExceptionPolicy'},
        'get_customer_configuration': {'method': 'GET', 'path': '/api/v1/customerConfiguration'},
        'update_customer_configuration': {'method': 'PUT', 'path': '/api/v1/customerConfiguration'},
        'get_cluster': {'method': 'GET', 'path': '/api/v1/cluster'},
        'get_cluster_with_risk_status': {'method': 'GET', 'path': '/api/v1/cluster'},
        'delete_cluster': {'method': 'DELETE', 'path': '/api/v1/cluster'},
        'get_image_scan_stats': {'method': 'GET', 'path': '/api/v1/customerState/reports/imageScan'},
        'create_kubescape_job_request': {'method': 'POST', 'path': '/api/v1/posture/scan'},
        'update_kubescape_job_request': {'method': 'PUT', 'path': '/api/v1/posture/scan'},
        'delete_kubescape_job_request': {'method': 'DELETE', 'path': '/api/v1/posture/scan'},
        'create_vuln_scan_job_request': {'method': 'POST', 'path': '/api/v1/vulnerability/scan/v2/'},
        'get_vuln_scan_cronjob_list': {'method': 'GET', 'path': '/api/v1/vulnerability/scan/v2/'},
        'get_vuln_scan_cronjob': {'method': 'GET', 'path': '/api/v1/vulnerability/scan/v2/'},
        'update_vuln_scan_cronjob': {'method': 'PUT', 'path': '/api/v1/vulnerability/scan/v2/'},
        'delete_vuln_scan_cronjob': {'method': 'DELETE', 'path': '/api/v1/vulnerability/scan/v2/'},
        'get_attack_chains': {'method': 'POST', 'path': '/api/v1/attackchains'},
        'get_active_attack_chains': {'method': 'POST', 'path': '/api/v1/attackchains'},
        'has_active_attack_chains': {'method': 'POST', 'path': '/api/v1/attackchains'},
        'get_network_policies': {'method': 'POST', 'path': '/api/v1/networkpolicies'},
        'get_network_policies_generate': {'method': 'POST', 'path': '/api/v1/networkpolicies/generate'},
        'get_known_servers_cache': {'method': 'GET', 'path': '/api/v1/networkpolicies/knownserverscache'},
        'get_security_risks_list': {'method': 'POST', 'path': '/api/v1/securityrisks/list'},
        'get_security_risks_severities': {'method': 'POST', 'path': '/api/v1/securityrisks/severities'},
        'get_security_risks_categories': {'method': 'POST', 'path': '/api/v1/securityrisks/categories'},
        'get_security_risks_trends': {'method': 'POST', 'path': '/api/v1/securityrisks/trends'},
        'get_security_risks_list_uniquevalues': {'method': 'POST', 'path': '/api/v1/uniqueValues/securityrisks/list'},
        'get_security_risks_resources': {'method': 'POST', 'path': '/api/v1/securityrisks/resources'},
        'add_security_risks_exception': {'method': 'POST', 'path': '/api/v1/securityrisks/exceptions/new'},
        'get_security_risks_exceptions_list': {'method': 'POST', 'path': '/api/v1/securityrisks/exceptions/list'},
        'put_security_risks_exception': {'method': 'PUT', 'path': '/api/v1/securityrisks/exceptions'},
        'delete_security_risks_exception': {'method': 'DELETE', 'path': '/api/v1/securityrisks/exceptions'},
        'get_scan_status': {'method': 'GET', 'path': '/api/v1/scanStatus'},
        'get_incidents': {'method': 'POST', 'path': '/api/v1/runtime/incidents'},
        'get_incident': {'method': 'GET', 'path': '/api/v1/runtime/incidents/{incident_id}'},
        'response_incident': {'method': 'POST', 'path': '/api/v1/runtime/incidents/{incident_id}/response'},
        'audit_log_incident': {'method': 'POST', 'path': '/api/v1/runtime/incidents/{incident_id}/auditlog'},
        'resolve_incident': {'method': 'POST', 'path': '/api/v1/runtime/incidents/{incident_id}/resolve'},
        'change_incident_status': {'method': 'POST', 'path': '/api/v1/runtime/incidents/changeStatus'},
        'get_alerts_of_incident': {'method': 'POST', 'path': '/api/v1/runtime/incidents/{incident_id}/alerts/list'},
        'get_process_graph': {'method': 'GET', 'path': '/api/v1/runtime/incidents/{incident_id}/process'},
        'get_incident_unique_values': {'method': 'POST', 'path': '/api/v1/uniqueValues/incidents'},
        'get_alerts_unique_values': {'method': 'POST', 'path': '/api/v1/runtime/incidents/{incident_id}/alerts/uniqueValues'},
        'get_incidents_per_severity': {'method': 'POST', 'path': '/api/v1/runtime/incidentsPerSeverity'},
        'get_incidents_overtime': {'method': 'POST', 'path': '/api/v1/runtime/incidentsOvertime'},
        'get_runtime_incidents_rulesets': {'method': 'POST', 'path': '/api/v1/runtime/incidentsRuleSet'},
        'get_runtime_incident_types': {'method': 'POST', 'path': '/api/v1/runtime/incidentTypes'},
        'get_runtime_policies_list': {'method': 'POST', 'path': '/api/v1/runtime/policies/list'},
        'delete_runtime_policies': {'method': 'DELETE', 'path': '/api/v1/runtime/policies'},
        'new_runtime_policy': {'method': 'POST', 'path': '/api/v1/runtime/policies'},
        'update_runtime_policy': {'method': 'PUT', 'path': '/api/v1/runtime/policies'},
        'get_runtime_policies_uniquevalues': {'method': 'POST', 'path': '/api/v1/uniqueValues/runtimeIncidentPolicy'},
        'get_seccomp_workloads_list': {'method': 'POST', 'path': '/api/v1/seccomp/list'},
        'generate_seccomp_profile': {'method': 'POST', 'path': '/api/v1/seccomp/generate'},
        'get_workflows': {'method': 'POST', 'path': '/api/v1/workflows'},
        'create_workflow': {'method': 'POST', 'path': '/api/v1/workflows'},
        'delete_workflow': {'method': 'DELETE', 'path': '/api/v1/workflows'},
        'update_workflow': {'method': 'PUT', 'path': '/api/v1/workflows'},
        'active_workflow': {'method': 'POST', 'path': '/api/v1/admin/activateWorkflows'},
        'convert_and_activate_workflows': {'method': 'POST', 'path': '/api/v1/admin/convertAndActivateWorkflows'},
        'get_notifications_unsubscribed': {'method': 'GET', 'path': '/api/v1/notifications/unsubscribe'},
        'add_notifications_unsubscribed': {'method': 'POST', 'path': '/api/v1/notifications/unsubscribe'},
        'remove_notifications_unsubscribed': {'method': 'DELETE', 'path': '/api/v1/notifications/unsubscribe'},
        'get_all_alert_channels': {'method': 'GET', 'path': '/api/v1/notifications/alertChannel'},
        'get_alert_channel': {'method': 'GET', 'path': '/api/v1/notifications/alertChannel'},
        'send_test_message': {'method': 'POST', 'path': '/api/v1/notifications/alertChannel'},
        'create_alert_channel': {'method': 'POST', 'path': '/api/v1/notifications/alertChannel'},
        'update_alert_channel': {'method': 'PUT', 'path': '/api/v1/notifications/alertChannel'},
        'remove_alert_channel': {'method': 'DELETE', 'path': '/api/v1/notifications/alertChannel'},
        'get_teams_webhooks': {'method': 'GET', 'path': '/api/v1/notifications/teams'},
        'create_teams_webhook': {'method': 'POST', 'path': '/api/v1/notifications/teams'},
        'delete_teams_webhook': {'method': 'DELETE', 'path': '/api/v1/notifications/teams'},
        'update_teams_webhook': {'method': 'PUT', 'path': '/api/v1/notifications/teams'},
        'test_teams_webhook_message': {'method': 'POST', 'path': '/api/v1/notifications/teams/testMessage'},
        'get_webhooks': {'method': 'GET', 'path': '/api/v1/notifications/webhooks'},
        'create_webhook': {'method': 'POST', 'path': '/api/v1/notifications/webhooks'},
        'delete_webhook': {'method': 'DELETE', 'path': '/api/v1/notifications/webhooks'},
        'update_webhook': {'method': 'PUT', 'path': '/api/v1/notifications/webhooks'},
        'test_webhook_message': {'method': 'POST', 'path': '/api/v1/notifications/webhooks/testMessage'},
        'check_registry': {'method': 'POST', 'path': '/api/v1/registry/management'},
        'create_registry': {'method': 'POST', 'path': '/api/v1/registry/management'},
        'get_registry': {'method': 'GET', 'path': '/api/v1/registry/management'},
        'get_all_registries': {'method': 'GET', 'path': '/api/v1/registry/management'},
        'update_registry': {'method': 'PUT', 'path': '/api/v1/registry/management'},
        'delete_registry': {'method': 'DELETE', 'path': '/api/v1/registry/management'},
        'get_integration_status': {'method': 'GET', 'path': '/api/v1/integrations'},
        'get_linear_config': {'method': 'GET', 'path': '/api/v1/integrations'},
        'create_linear_issue': {'method': 'POST', 'path': '/api/v1/integrations'},
        'update_linear_ticket_status': {'method': 'PUT', 'path': '/api/v1/integrations'},
        'search_linear_field_values': {'method': 'POST', 'path': '/api/v1/integrations'},
        'get_jira_config': {'method': 'GET', 'path': '/api/v1/integrations'},
        'update_jira_ticket_status': {'method': 'PUT', 'path': '/api/v1/integrations'},
        'get_jira_collaboration_guid_by_site_name': {'method': 'GET', 'path': '/api/v1/integrations'},
        'update_jira_config': {'method': 'PUT', 'path': '/api/v1/integrations'},
        'search_jira_projects': {'method': 'POST', 'path': '/api/v1/integrations'},
        'search_jira_issue_types': {'method': 'POST', 'path': '/api/v1/integrations'},
        'search_jira_schema': {'method': 'POST', 'path': '/api/v1/integrations'},
        'search_jira_issue_field': {'method': 'POST', 'path': '/api/v1/integrations'},
        'create_jira_issue': {'method': 'POST', 'path': '/api/v1/integrations'},
        'unlink_issue': {'method': 'DELETE', 'path': '/api/v1/integrations'},
        'get_kubernetes_resources': {'method': 'POST', 'path': '/api/v1/kubernetesresources'},
        'get_accounts_cloud_list': {'method': 'POST', 'path': '/api/v1/accounts/cloud/list'},
        'get_accounts_kubernetes_list': {'method': 'POST', 'path': '/api/v1/accounts/kubernetes/list'},
        'get_cspm_single_link': {'method': 'POST', 'path': '/api/v1/accounts/aws/cspmfeatures'},
        'get_cadr_link': {'method': 'POST', 'path': '/api/v1/accounts/aws/cadrstack'},
        'get_cadr_org_link': {'method': 'POST', 'path': '/api/v1/accounts/aws/orgstacks/cadr'},
        'get_cspm_members_org_link': {'method': 'POST', 'path': '/api/v1/accounts/aws/orgstacks/cspmmembers'},
        'get_cspm_admin_org_link': {'method': 'POST', 'path': '/api/v1/accounts/aws/orgstacks/cspmadmin'},
        'delete_accounts_feature': {'method': 'DELETE', 'path': '/api/v1/accounts/feature'},
        'get_aws_regions': {'method': 'GET', 'path': '/api/v1/accounts/aws/regions'},
        'get_aws_regions_details': {'method': 'GET', 'path': '/api/v1/accounts/aws/regionsdetails'},
        'get_cloud_compliance_accounts': {'method': 'POST', 'path': '/api/v1/cloudposture/accounts'},
        'get_cloud_compliance_controls': {'method': 'POST', 'path': '/api/v1/cloudposture/controls'},
        'get_cloud_compliance_rules': {'method': 'POST', 'path': '/api/v1/cloudposture/rules'},
        'get_cloud_compliance_resources': {'method': 'POST', 'path': '/api/v1/cloudposture/resources'},
        'create_siem_integration': {'method': 'POST', 'path': '/api/v1/siem/{provider}'},
        'update_siem_integration': {'method': 'PUT', 'path': '/api/v1/siem/{provider}'},
        'delete_siem_integration': {'method': 'DELETE', 'path': '/api/v1/siem/{provider}'},
    }

def _evaluate_concat_expression(expr: str, definitions: Dict[str, str], max_depth: int = 8) -> Optional[str]:
    """
    Best-effort evaluation for expressions like:
      API_FOO = API_BASE + \"bar\" + \"/baz\"
    Returns a resolved string if possible.
    """
    expr = (expr or "").strip()
    if not expr:
        return None

    # string literal
    if (expr.startswith("'") and expr.endswith("'")) or (expr.startswith('"') and expr.endswith('"')):
        return expr[1:-1]

    if max_depth <= 0:
        return None

    # Support basic concatenation with '+'
    parts = [p.strip().strip("() ") for p in expr.split("+")]
    if len(parts) >= 2:
        out = ""
        for part in parts:
            if not part:
                continue
            if (part.startswith("'") and part.endswith("'")) or (part.startswith('"') and part.endswith('"')):
                out += part[1:-1]
                continue
            if part in definitions:
                resolved = _evaluate_concat_expression(definitions[part], definitions, max_depth=max_depth - 1)
                if resolved is None:
                    return None
                out += resolved
                continue
            return None
        return out

    # Reference to another const
    if expr in definitions:
        return _evaluate_concat_expression(definitions[expr], definitions, max_depth=max_depth - 1)

    return None


def _extract_backend_api_method_mapping(repo_root: Path) -> Dict[str, Dict[str, str]]:
    """
    Best-effort extraction of backend method -> {method, path} from infrastructure/backend_api.py.
    This is used as a fallback when get_api_method_mapping() doesn't include a method.
    """
    backend_api = repo_root / "infrastructure" / "backend_api.py"
    if not backend_api.exists():
        return {}

    try:
        text = backend_api.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        text = backend_api.read_text(errors="ignore")

    # Collect constant definitions (simple assignment lines). Many are concatenations.
    assign_re = re.compile(r"^(?P<k>(API|BASE)_[A-Z0-9_]+)\s*=\s*(?P<rhs>.+?)\s*$", re.M)
    raw_defs: Dict[str, str] = {m.group("k"): m.group("rhs") for m in assign_re.finditer(text)}

    resolved_consts: Dict[str, str] = {}
    for k, rhs in raw_defs.items():
        val = _evaluate_concat_expression(rhs, raw_defs)
        if isinstance(val, str) and "/api/" in val:
            resolved_consts[k] = val

    # Parse with AST to discover per-method verbs and url sources.
    try:
        tree = ast.parse(text)
    except Exception:
        return {}

    results: Dict[str, Dict[str, str]] = {}

    def resolve_path_from_value(node) -> Optional[str]:
        # url = API_CONST
        if isinstance(node, ast.Name) and node.id in resolved_consts:
            return resolved_consts[node.id]
        # url = BASE_API + "/suffix"
        if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
            # convert to string if possible by folding Name/Constant
            parts = []
            def walk(n):
                if isinstance(n, ast.BinOp) and isinstance(n.op, ast.Add):
                    walk(n.left); walk(n.right); return
                if isinstance(n, ast.Name) and n.id in resolved_consts:
                    parts.append(resolved_consts[n.id]); return
                if isinstance(n, ast.Constant) and isinstance(n.value, str):
                    parts.append(n.value); return
            walk(node)
            s = "".join(parts)
            if "/api/" in s:
                return s[s.find("/api/"):]
        # f"{API_CONST}/{param}"  (JoinedStr)
        if isinstance(node, ast.JoinedStr):
            base = ""
            for v in node.values:
                if isinstance(v, ast.Constant) and isinstance(v.value, str):
                    base += v.value
                elif isinstance(v, ast.FormattedValue):
                    # treat formatted values as placeholder
                    base += "{param}"
            if "/api/" in base:
                return base[base.find("/api/"):]
        return None

    for fn in [n for n in tree.body if isinstance(n, ast.FunctionDef)]:
        # backend_api.py is a class-heavy file; methods are inside class defs
        pass
    for cls in [n for n in tree.body if isinstance(n, ast.ClassDef)]:
        for fn in [n for n in cls.body if isinstance(n, ast.FunctionDef)]:
            verb = None
            path = None
            # Find r = self.<verb>(...) call and try to resolve its first argument or url var
            for n in ast.walk(fn):
                if isinstance(n, ast.Assign) and len(n.targets) == 1 and isinstance(n.targets[0], ast.Name) and n.targets[0].id == "url":
                    path = path or resolve_path_from_value(n.value)
                if isinstance(n, ast.Call) and isinstance(n.func, ast.Attribute) and isinstance(n.func.value, ast.Name) and n.func.value.id == "self":
                    if n.func.attr in ("get", "post", "put", "delete"):
                        verb = verb or n.func.attr.upper()
                        if n.args:
                            path = path or resolve_path_from_value(n.args[0])
            if verb and path and "/api/" in path:
                # normalize to path only (strip scheme/host if any)
                if "://" in path:
                    path = path[path.find("/api/"):]
                results[fn.name] = {"method": verb, "path": path}

    return results


def build_api_method_mapping(repo_root: Path = REPO_ROOT) -> Dict[str, Dict[str, str]]:
    """
    Combined mapping:
    - Static table from get_api_method_mapping() (kept for stability)
    - Dynamic extraction from backend_api.py as a fallback (fills gaps)
    """
    mapping = dict(get_api_method_mapping())
    dynamic = _extract_backend_api_method_mapping(repo_root)
    # Do not override existing keys (static table is source of truth where present)
    for k, v in dynamic.items():
        if k not in mapping:
            mapping[k] = v
    return mapping


def find_base_classes(file_path):
    """Find base classes that a test file might inherit from."""
    base_files = []
    
    # Common base class patterns
    if 'helm/' in str(file_path):
        base_files.extend([
            'tests_scripts/helm/base_helm.py',
            'tests_scripts/kubernetes/base_k8s.py'
        ])
    
    if 'vuln_scan' in str(file_path) or 'relevant_cve' in str(file_path):
        if 'tests_scripts/helm/base_vuln_scan.py' not in base_files:
            base_files.append('tests_scripts/helm/base_vuln_scan.py')
    
    if 'network_policy' in str(file_path):
        if 'tests_scripts/helm/base_network_policy.py' not in base_files:
            base_files.append('tests_scripts/helm/base_network_policy.py')
    
    if 'kubescape/' in str(file_path):
        base_files.append('tests_scripts/kubescape/base_kubescape.py')
    
    if 'runtime/' in str(file_path):
        base_files.append('tests_scripts/runtime/base_runtime.py')
        # Also include common runtime test classes that tests inherit from
        if 'cadr' in str(file_path) or 'incidents' in str(file_path):
            base_files.append('tests_scripts/runtime/incidents.py')
    
    if 'payments/' in str(file_path):
        base_files.extend([
            'tests_scripts/payments/base_payment.py',
            'tests_scripts/payments/base_stripe.py'
        ])
    
    if 'workflows/' in str(file_path):
        if 'tests_scripts/workflows/workflows.py' not in base_files:
            base_files.append('tests_scripts/workflows/workflows.py')

    # Accounts tests commonly inherit from Accounts base class, which contains most backend calls.
    if 'tests_scripts/accounts/' in str(file_path):
        if 'tests_scripts/accounts/accounts.py' not in base_files:
            base_files.append('tests_scripts/accounts/accounts.py')
    
    return base_files

def update_system_mapping():
    """Update system_test_mapping.json with all fields."""
    
    print("ðŸ” Analyzing test configuration files...")
    config_mappings = analyze_test_configuration_files()
    
    print("ðŸ“– Loading system test mapping...")
    mapping_file = REPO_ROOT / 'system_test_mapping.json'
    system_mapping = load_json_file(str(mapping_file))
    api_method_mapping = build_api_method_mapping(REPO_ROOT)
    
    tests_dir = REPO_ROOT / 'tests_scripts'
    updated_count = 0
    tests_with_impl_files = 0
    tests_with_apis = 0
    
    for test_name, test_config in system_mapping.items():
        # Get implementation files from config analysis
        impl_files = config_mappings.get(test_name, [])
        
        # Add base class files if applicable
        all_files = set(impl_files)
        for impl_file in impl_files:
            file_path = REPO_ROOT / impl_file
            base_files = find_base_classes(file_path)
            all_files.update(base_files)
        
        # Convert to sorted list
        impl_files_list = sorted(list(all_files))
        
        # Update test_implementation_files
        if impl_files_list:
            test_config['test_implementation_files'] = impl_files_list
            tests_with_impl_files += 1
        else:
            test_config['test_implementation_files'] = []
        
        # Extract API calls from implementation files
        api_methods = set()
        for impl_file in impl_files_list:
            file_path = REPO_ROOT / impl_file
            methods = extract_backend_api_calls(file_path)
            api_methods.update(methods)
        
        # Convert to API format with HTTP methods
        api_list = []
        seen_apis = set()  # Track (method, path) to avoid duplicates
        for method_name in api_methods:
            if method_name in api_method_mapping:
                api_info = api_method_mapping[method_name]
                api_key = (api_info['method'], api_info['path'])
                if api_key not in seen_apis:
                    seen_apis.add(api_key)
                    api_list.append(api_info)
        
        # Note: Paths with {param_name} placeholders (e.g., {incident_id}) represent
        # dynamic path parameters. The API mapping script (map_apis_to_code.py) uses
        # partial matching to find handlers, so these will match endpoints in the code index.
        
        # Sort for consistency
        api_list.sort(key=lambda x: (x['path'], x['method']))
        
        # Store tested_dashboard_apis separately for artifact (not in source file)
        # We'll add it to the artifact version later
        if api_list:
            tests_with_apis += 1
        
        updated_count += 1
    
    # Remove tested_dashboard_apis from source mapping (if it exists from old version)
    for test_config in system_mapping.values():
        test_config.pop('tested_dashboard_apis', None)
    
    # Create artifact version with tested_dashboard_apis included
    artifact_mapping = {}
    for test_name, test_config in system_mapping.items():
        artifact_config = test_config.copy()
        
        # Re-extract API calls for this test to add to artifact
        impl_files_list = artifact_config.get('test_implementation_files', [])
        api_methods = set()
        for impl_file in impl_files_list:
            file_path = REPO_ROOT / impl_file
            methods = extract_backend_api_calls(file_path)
            api_methods.update(methods)
        
        # Convert to API format with HTTP methods
        api_list = []
        seen_apis = set()
        for method_name in api_methods:
            if method_name in api_method_mapping:
                api_info = api_method_mapping[method_name]
                api_key = (api_info['method'], api_info['path'])
                if api_key not in seen_apis:
                    seen_apis.add(api_key)
                    api_list.append(api_info)
        
        api_list.sort(key=lambda x: (x['path'], x['method']))
        artifact_config['tested_dashboard_apis'] = api_list
        artifact_mapping[test_name] = artifact_config
    
    # Save source file WITHOUT tested_dashboard_apis
    save_json_file(str(mapping_file), system_mapping)
    
    # Save artifact file WITH tested_dashboard_apis
    artifact_file = REPO_ROOT / 'system_test_mapping_artifact.json'
    save_json_file(str(artifact_file), artifact_mapping)
    
    print(f"\nâœ… Update complete!")
    print(f"   â€¢ Total tests: {updated_count}")
    print(f"   â€¢ Tests with implementation files: {tests_with_impl_files}")
    print(f"   â€¢ Tests with API mappings: {tests_with_apis}")
    
    # Show examples
    print(f"\nðŸ“ Sample test with new fields:")
    for test_name in ['stripe_plans', 'jira_integration', 'network_policy']:
        if test_name in system_mapping:
            config = system_mapping[test_name]
            impl_files = config.get('test_implementation_files', [])
            apis = config.get('tested_dashboard_apis', [])
            if impl_files and apis:
                print(f"\n{test_name}:")
                print(f"  Implementation files ({len(impl_files)}):")
                for f in impl_files[:2]:
                    print(f"    â€¢ {f}")
                if len(impl_files) > 2:
                    print(f"    ... and {len(impl_files) - 2} more")
                print(f"  APIs ({len(apis)}):")
                for api in apis[:2]:
                    print(f"    â€¢ {api['method']:6} {api['path']}")
                if len(apis) > 2:
                    print(f"    ... and {len(apis) - 2} more")
                break

if __name__ == '__main__':
    import sys
    sys.stdout.write("="*70 + "\n")
    sys.stdout.write("  Updating System Test Mapping\n")
    sys.stdout.write("="*70 + "\n\n")
    sys.stdout.flush()
    
    try:
        update_system_mapping()
    except Exception as e:
        sys.stderr.write(f"ERROR: {e}\n")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    
    sys.stdout.write("\n" + "="*70 + "\n")
    sys.stdout.write("âœ¨ Done!\n")
    sys.stdout.write("="*70 + "\n")
    sys.stdout.flush()
